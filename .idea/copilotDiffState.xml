<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/scripts/train_ensemble_colab.ipynb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/train_ensemble_colab.ipynb" />
              <option name="originalContent" value="{&#10; &quot;cells&quot;: [&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;# Entraînement des modèles LSTM, GRU et Random Forest\n&quot;,&#10;    &quot;Ce notebook permet d'entraîner des modèles d'apprentissage automatique pour détecter les domaines malveillants.&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Importation des bibliothèques nécessaires\n&quot;,&#10;    &quot;import argparse\n&quot;,&#10;    &quot;import math\n&quot;,&#10;    &quot;import json\n&quot;,&#10;    &quot;from pathlib import Path\n&quot;,&#10;    &quot;from typing import Any, Dict, Optional\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;import joblib\n&quot;,&#10;    &quot;import numpy as np\n&quot;,&#10;    &quot;import pandas as pd\n&quot;,&#10;    &quot;from sklearn.ensemble import RandomForestClassifier\n&quot;,&#10;    &quot;from sklearn.metrics import (\n&quot;,&#10;    &quot;    accuracy_score,\n&quot;,&#10;    &quot;    f1_score,\n&quot;,&#10;    &quot;    precision_score,\n&quot;,&#10;    &quot;    recall_score,\n&quot;,&#10;    &quot;    roc_auc_score,\n&quot;,&#10;    &quot;    make_scorer,\n&quot;,&#10;    &quot;    classification_report\n&quot;,&#10;    &quot;    )\n&quot;,&#10;    &quot;from sklearn.model_selection import GridSearchCV, StratifiedKFold, train_test_split\n&quot;,&#10;    &quot;from sklearn.preprocessing import StandardScaler\n&quot;,&#10;    &quot;import tensorflow as tf\n&quot;,&#10;    &quot;from tensorflow import keras\n&quot;,&#10;    &quot;from tensorflow.keras import layers\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;try:\n&quot;,&#10;    &quot;    from xgboost import XGBClassifier\n&quot;,&#10;    &quot;    XGBOOST_AVAILABLE = True\n&quot;,&#10;    &quot;except ImportError:\n&quot;,&#10;    &quot;    XGBOOST_AVAILABLE = False&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## Chargement et prétraitement des données&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Définition des chemins\n&quot;,&#10;    &quot;PROJECT_ROOT = Path('__file__').resolve().parent.parent\n&quot;,&#10;    &quot;DATA_FILE = PROJECT_ROOT / 'data' / 'train' / 'train_domains.csv'\n&quot;,&#10;    &quot;MODELS_DIR = PROJECT_ROOT / 'models'\n&quot;,&#10;    &quot;SCALER_PATH = MODELS_DIR / 'scaler.joblib'\n&quot;,&#10;    &quot;METRICS_PATH = MODELS_DIR / 'training_metrics.json'\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Chargement des données\n&quot;,&#10;    &quot;def load_dataset(csv_file: Path | str = DATA_FILE):\n&quot;,&#10;    &quot;    df = pd.read_csv(csv_file)\n&quot;,&#10;    &quot;    print(f'Total samples: {len(df)}')\n&quot;,&#10;    &quot;    return df&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## Entraînement des modèles&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Exemple d'entraînement d'un modèle LSTM\n&quot;,&#10;    &quot;def train_lstm(data):\n&quot;,&#10;    &quot;    model = keras.Sequential([\n&quot;,&#10;    &quot;        layers.LSTM(64, return_sequences=True, input_shape=(15, 1)),\n&quot;,&#10;    &quot;        layers.Dropout(0.2),\n&quot;,&#10;    &quot;        layers.LSTM(32),\n&quot;,&#10;    &quot;        layers.Dropout(0.2),\n&quot;,&#10;    &quot;        layers.Dense(16, activation='relu'),\n&quot;,&#10;    &quot;        layers.Dense(1, activation='sigmoid')\n&quot;,&#10;    &quot;    ])\n&quot;,&#10;    &quot;    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n&quot;,&#10;    &quot;    model.fit(data['X_train'], data['y_train'], epochs=10, batch_size=32)\n&quot;,&#10;    &quot;    return model&quot;&#10;   ]&#10;  }&#10; ],&#10; &quot;metadata&quot;: {&#10;  &quot;kernelspec&quot;: {&#10;   &quot;display_name&quot;: &quot;Python 3&quot;,&#10;   &quot;language&quot;: &quot;python&quot;,&#10;   &quot;name&quot;: &quot;python3&quot;&#10;  },&#10;  &quot;language_info&quot;: {&#10;   &quot;codemirror_mode&quot;: {&#10;    &quot;name&quot;: &quot;ipython&quot;,&#10;    &quot;version&quot;: 3&#10;   },&#10;   &quot;file_extension&quot;: &quot;.py&quot;,&#10;   &quot;mimetype&quot;: &quot;text/x-python&quot;,&#10;   &quot;name&quot;: &quot;python&quot;,&#10;   &quot;nbconvert_exporter&quot;: &quot;python&quot;,&#10;   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,&#10;   &quot;version&quot;: &quot;3.8.5&quot;&#10;  }&#10; },&#10; &quot;nbformat&quot;: 4,&#10; &quot;nbformat_minor&quot;: 4&#10;}" />
              <option name="updatedContent" value="{&#10; &quot;cells&quot;: [&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;# Entraînement des modèles LSTM, GRU et Random Forest\n&quot;,&#10;    &quot;Ce notebook permet d'entraîner des modèles d'apprentissage automatique pour détecter les domaines malveillants.&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Importation des bibliothèques nécessaires\n&quot;,&#10;    &quot;import argparse\n&quot;,&#10;    &quot;import math\n&quot;,&#10;    &quot;import json\n&quot;,&#10;    &quot;from pathlib import Path\n&quot;,&#10;    &quot;from typing import Any, Dict, Optional\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;import joblib\n&quot;,&#10;    &quot;import numpy as np\n&quot;,&#10;    &quot;import pandas as pd\n&quot;,&#10;    &quot;from sklearn.ensemble import RandomForestClassifier\n&quot;,&#10;    &quot;from sklearn.metrics import (\n&quot;,&#10;    &quot;    accuracy_score,\n&quot;,&#10;    &quot;    f1_score,\n&quot;,&#10;    &quot;    precision_score,\n&quot;,&#10;    &quot;    recall_score,\n&quot;,&#10;    &quot;    roc_auc_score,\n&quot;,&#10;    &quot;    make_scorer,\n&quot;,&#10;    &quot;    classification_report\n&quot;,&#10;    &quot;    )\n&quot;,&#10;    &quot;from sklearn.model_selection import GridSearchCV, StratifiedKFold, train_test_split\n&quot;,&#10;    &quot;from sklearn.preprocessing import StandardScaler\n&quot;,&#10;    &quot;import tensorflow as tf\n&quot;,&#10;    &quot;from tensorflow import keras\n&quot;,&#10;    &quot;from tensorflow.keras import layers\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;try:\n&quot;,&#10;    &quot;    from xgboost import XGBClassifier\n&quot;,&#10;    &quot;    XGBOOST_AVAILABLE = True\n&quot;,&#10;    &quot;except ImportError:\n&quot;,&#10;    &quot;    XGBOOST_AVAILABLE = False&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## Chargement et prétraitement des données&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Définition des chemins\n&quot;,&#10;    &quot;PROJECT_ROOT = Path('__file__').resolve().parent.parent\n&quot;,&#10;    &quot;DATA_FILE = PROJECT_ROOT / 'data' / 'train' / 'train_domains.csv'\n&quot;,&#10;    &quot;MODELS_DIR = PROJECT_ROOT / 'models'\n&quot;,&#10;    &quot;SCALER_PATH = MODELS_DIR / 'scaler.joblib'\n&quot;,&#10;    &quot;METRICS_PATH = MODELS_DIR / 'training_metrics.json'\n&quot;,&#10;    &quot;\n&quot;,&#10;    &quot;# Chargement des données\n&quot;,&#10;    &quot;def load_dataset(csv_file: Path | str = DATA_FILE):\n&quot;,&#10;    &quot;    df = pd.read_csv(csv_file)\n&quot;,&#10;    &quot;    print(f'Total samples: {len(df)}')\n&quot;,&#10;    &quot;    return df&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;markdown&quot;,&#10;   &quot;metadata&quot;: {},&#10;   &quot;source&quot;: [&#10;    &quot;## Entraînement des modèles&quot;&#10;   ]&#10;  },&#10;  {&#10;   &quot;cell_type&quot;: &quot;code&quot;,&#10;   &quot;execution_count&quot;: null,&#10;   &quot;metadata&quot;: {},&#10;   &quot;outputs&quot;: [],&#10;   &quot;source&quot;: [&#10;    &quot;# Exemple d'entraînement d'un modèle LSTM\n&quot;,&#10;    &quot;def train_lstm(data):\n&quot;,&#10;    &quot;    model = keras.Sequential([\n&quot;,&#10;    &quot;        layers.LSTM(64, return_sequences=True, input_shape=(15, 1)),\n&quot;,&#10;    &quot;        layers.Dropout(0.2),\n&quot;,&#10;    &quot;        layers.LSTM(32),\n&quot;,&#10;    &quot;        layers.Dropout(0.2),\n&quot;,&#10;    &quot;        layers.Dense(16, activation='relu'),\n&quot;,&#10;    &quot;        layers.Dense(1, activation='sigmoid')\n&quot;,&#10;    &quot;    ])\n&quot;,&#10;    &quot;    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n&quot;,&#10;    &quot;    model.fit(data['X_train'], data['y_train'], epochs=10, batch_size=32)\n&quot;,&#10;    &quot;    return model&quot;&#10;   ]&#10;  }&#10; ],&#10; &quot;metadata&quot;: {&#10;  &quot;kernelspec&quot;: {&#10;   &quot;display_name&quot;: &quot;Python 3&quot;,&#10;   &quot;language&quot;: &quot;python&quot;,&#10;   &quot;name&quot;: &quot;python3&quot;&#10;  },&#10;  &quot;language_info&quot;: {&#10;   &quot;codemirror_mode&quot;: {&#10;    &quot;name&quot;: &quot;ipython&quot;,&#10;    &quot;version&quot;: 3&#10;   },&#10;   &quot;file_extension&quot;: &quot;.py&quot;,&#10;   &quot;mimetype&quot;: &quot;text/x-python&quot;,&#10;   &quot;name&quot;: &quot;python&quot;,&#10;   &quot;nbconvert_exporter&quot;: &quot;python&quot;,&#10;   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,&#10;   &quot;version&quot;: &quot;3.8.5&quot;&#10;  }&#10; },&#10; &quot;nbformat&quot;: 4,&#10; &quot;nbformat_minor&quot;: 4&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>